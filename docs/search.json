[{"path":"https://numerious.github.io/evalR/articles/Overview.html","id":"overview","dir":"Articles","previous_headings":"","what":"Overview","title":"Overview","text":"purpose package generate verification trees evaluations user supplied statements. Trees made parsing statement data structure composed lists. Safe statement evaluations done executing verification trees.","code":""},{"path":"https://numerious.github.io/evalR/articles/Overview.html","id":"verification-trees","dir":"Articles","previous_headings":"Overview","what":"Verification Trees","title":"Overview","text":"statement can represented tree data structure. quote Wikipedia explain concept: computer science, tree widely used abstract data type represents hierarchical tree structure set connected nodes. node tree can connected many children (depending type tree), must connected exactly one parent, except root node, parent. constraints mean cycles “loops” (node can ancestor), also child can treated like root node subtree, making recursion useful technique tree traversal. contrast linear data structures, many trees represented relationships neighboring nodes single straight line. default package know parse R statement tree. theory, supply tokens use package parse language follows similar grammar. verification trees used port R statements languages. example, one use case write formulas excel replicate calculations done R.","code":""},{"path":"https://numerious.github.io/evalR/articles/Overview.html","id":"safe-evaluation","dir":"Articles","previous_headings":"Overview","what":"Safe Evaluation","title":"Overview","text":"Writing code executes unverified code can powerful dangerous. common approach following pattern: power comes flexibility pattern gives us. usually comes significant performance cost, CPU time cheaper developers. danger comes unknown unknowns. input personal computer may pose much risk. hold input nefarious/clever users server. Execution verification tree generated unverified code different story. risk limited deemed acceptable based supplied tokens. comes greater performance cost, removes danger unverified code.","code":"eval(parse(text=\"unverified_code\"))"},{"path":"https://numerious.github.io/evalR/articles/Overview.html","id":"functions","dir":"Articles","previous_headings":"","what":"Functions","title":"Overview","text":"focus package limited just creating evaluating trees. next sections cover main functions.","code":""},{"path":"https://numerious.github.io/evalR/articles/Overview.html","id":"create_tree","dir":"Articles","previous_headings":"Functions","what":"create_tree","title":"Overview","text":"create_tree function takes string generates tree. example, can parse simple expression 2+3: can see structure list lists.","code":"x <- evalR::create_tree(\"2+3\") str(x) #> List of 2 #>  $ pval: list() #>  $ eval:List of 3 #>   ..$ : chr \"+\" #>   ..$ :List of 2 #>   .. ..$ : chr \"atomic\" #>   .. ..$ : chr \"2\" #>   ..$ :List of 2 #>   .. ..$ : chr \"atomic\" #>   .. ..$ : chr \"3\""},{"path":"https://numerious.github.io/evalR/articles/Overview.html","id":"under-the-hood","dir":"Articles","previous_headings":"Functions > create_tree","what":"Under the hood","title":"Overview","text":"don’t need understand structure tree use . Just like can drive car without knowing engine works. section help reveal trees formed. First lets confirm can replicate tree structure: test passes zero error. full tree made two main branches: pval - stands parenthesis values eval - stands verification values","code":"tree <- list(   pval = list(),   eval = list(\"+\", list(\"atomic\", \"2\"), list(\"atomic\", \"3\")) ) testthat::expect_equal(x,tree)"},{"path":"https://numerious.github.io/evalR/articles/Overview.html","id":"pval","dir":"Articles","previous_headings":"Functions > create_tree > Under the hood","what":"pval","title":"Overview","text":"first thing function find parenthesis blocks treats sub statements. sub statements becomes element pval element. eval tree references pval entries. example, lets tweak 2+3 (2)+(3): replicate structure: test passes zero error. Now pval list empty. entry (2) (3). entry pval new tree unto contains pval eval branches.","code":"x <- evalR::create_tree(\"(2)+(3)\") str(x) #> List of 2 #>  $ pval:List of 2 #>   ..$ \\0:List of 2 #>   .. ..$ pval: list() #>   .. ..$ eval:List of 2 #>   .. .. ..$ : chr \"atomic\" #>   .. .. ..$ : chr \"2\" #>   ..$ \\1:List of 2 #>   .. ..$ pval: list() #>   .. ..$ eval:List of 2 #>   .. .. ..$ : chr \"atomic\" #>   .. .. ..$ : chr \"3\" #>  $ eval:List of 3 #>   ..$ : chr \"+\" #>   ..$ :List of 2 #>   .. ..$ : chr \"atomic\" #>   .. ..$ : chr \"\\\\0\" #>   ..$ :List of 2 #>   .. ..$ : chr \"atomic\" #>   .. ..$ : chr \"\\\\1\" pval_list <- list(   \"\\\\0\"=list(     pval = list(),     eval = list(\"atomic\", \"2\")   ),   \"\\\\1\"=list(     pval = list(),     eval = list(\"atomic\", \"3\")   ) ) tree <- list(   pval = pval_list,   eval = list(\"+\", list(\"atomic\", \"\\\\0\"), list(\"atomic\", \"\\\\1\")) ) testthat::expect_equal(x,tree)"},{"path":"https://numerious.github.io/evalR/articles/Overview.html","id":"eval","dir":"Articles","previous_headings":"Functions > create_tree > Under the hood","what":"eval","title":"Overview","text":"eval branch splits statement operators “atomic” elements. example, just parse 2: eval one level deep first element string atomic. signifies end node tree. Lets expand just little bit: Now eval two levels deep. first element states operator - second element another branch looks exactly like eval branch previous example. parenthesis block found, atomic element reference pval element: example, eval second level atomic element \\0. reference \\0 named element pval branch.","code":"x <- evalR::create_tree(\"2\") str(x) #> List of 2 #>  $ pval: list() #>  $ eval:List of 2 #>   ..$ : chr \"atomic\" #>   ..$ : chr \"2\" x <- evalR::create_tree(\"-2\") str(x) #> List of 2 #>  $ pval: list() #>  $ eval:List of 2 #>   ..$ : chr \"-\" #>   ..$ :List of 2 #>   .. ..$ : chr \"atomic\" #>   .. ..$ : chr \"2\" x <- evalR::create_tree(\"-(2)\") str(x) #> List of 2 #>  $ pval:List of 1 #>   ..$ \\0:List of 2 #>   .. ..$ pval: list() #>   .. ..$ eval:List of 2 #>   .. .. ..$ : chr \"atomic\" #>   .. .. ..$ : chr \"2\" #>  $ eval:List of 2 #>   ..$ : chr \"-\" #>   ..$ :List of 2 #>   .. ..$ : chr \"atomic\" #>   .. ..$ : chr \"\\\\0\""},{"path":"https://numerious.github.io/evalR/articles/Overview.html","id":"eval_tree","dir":"Articles","previous_headings":"Functions","what":"eval_tree","title":"Overview","text":"Given tree, can execute function eval_tree. basic example:","code":"x <- evalR::create_tree(\"2+3\") y <- evalR::eval_tree(x) print(y) #> [1] 5"},{"path":"https://numerious.github.io/evalR/articles/Overview.html","id":"eval_text","dir":"Articles","previous_headings":"Functions","what":"eval_text","title":"Overview","text":"convenience function contains tree creation stage. eval_text takes text input:","code":"y <- evalR::eval_text(\"2+3\") print(y) #> [1] 5"},{"path":"https://numerious.github.io/evalR/articles/Overview.html","id":"shared-parameters","dir":"Articles","previous_headings":"","what":"Shared Parameters","title":"Overview","text":"three functions share following parameters: singular_operators - tokens length 1 operate right hand value. example, - token operator negate vector. NULL value replaced c(\"-\", \"!\"). binary_operators - tokens length operate left right hand values. example, + token operator adds left vector right vector. NULL value replaced c(\",\",\"|\", \"&\", \"<=\", \"<\", \">=\", \">\", \"==\", \"!=\", \"+\", \"-\", \"*\", \"%/%\", \"/\", \"%%\", \"%%\", \":\", \"^\"). order determines precedence operators. valid_functions - tokens length prefixed parenthesis block specify function run provided parameters within block. example, log token evaluate logarithm value first parameter. Note named parameters support. NULL value replaced c(\"log\",\"c\", \"\",\"\", \"abs\",\"ifelse\"). example, want able use function rnorm, need provide item valid_functions parameter:","code":"y <- evalR::eval_text(\"2+rnorm(1)\", valid_functions=\"rnorm\") print(y) #> [1] 2.354399"},{"path":"https://numerious.github.io/evalR/articles/Overview.html","id":"map-parameter","dir":"Articles","previous_headings":"","what":"map Parameter","title":"Overview","text":"eval_tree eval_text share following parameter: map - named list data.frames/lists/matrices. names keys referencing values parameters. parameter limits scope execution environment (strictly technical sense). words, limit values can reference. basic concert example: complex example:","code":"map_obj <- list(\"#\" = data.frame(x = 1:5, y = 5:1)) y <- evalR::eval_text(\"log(#x#)\", map=map_obj) print(y) #> [1] 0.0000000 0.6931472 1.0986123 1.3862944 1.6094379 map_obj <- list(\"#\" = data.frame(x = 1:5, y = 5:1),\"$\" = list(z = -(1:5))) y <- evalR::eval_text(\"#x# + $z$\", map=map_obj) print(y) #> [1] 0 0 0 0 0"},{"path":"https://numerious.github.io/evalR/articles/Overview.html","id":"microbenchmark","dir":"Articles","previous_headings":"","what":"microbenchmark","title":"Overview","text":"get sense performance. Lets compare different ways can run log(1+2): pure R evaluation much faster methods. surprise. evalR::eval_tree block takes couple times longer eval(parse(text)) execution. trade considering reduced risk. eval(parse(text)) execution sometimes much slower ran outside R Markdown. also see evalR::eval_text takes much longer evalR::eval_tree. majority evalR::eval_text time comes internal call evalR::create_tree. free lunch principle comes play. cost reduced risk spent creating tree. ’re lucky enough set user input evaluated multiple times, design pattern generating tree using evalR::eval_tree give similar performance straight eval call.","code":"text <- \"log(1+3)\" tree <- evalR::create_tree(text) microbenchmark::microbenchmark(   {log(1+2)},   {eval(parse(text=text))},   {evalR::eval_tree(tree)},   {evalR::eval_text(text)},   {evalR::create_tree(text)}, n=1000) #> Warning in microbenchmark::microbenchmark({: Could not measure a positive #> execution time for 77 evaluations. #> Unit: nanoseconds #>                              expr    min     lq   mean median     uq    max #>                {     log(1 + 2) }    100    100    180    200    200    900 #>  {     eval(parse(text = text)) }   4000   5350   7170   6500   7250  47200 #>    {     evalR::eval_tree(tree) }  18700  20050  23928  21100  23150  89400 #>    {     evalR::eval_text(text) } 157500 159900 178438 162400 182250 302900 #>  {     evalR::create_tree(text) } 134500 136650 148148 138450 145300 253600 #>                                 n      0      0      1      0      0    100 #>  neval #>    100 #>    100 #>    100 #>    100 #>    100 #>    100"},{"path":"https://numerious.github.io/evalR/articles/Overview.html","id":"final-thoughts","dir":"Articles","previous_headings":"","what":"Final Thoughts","title":"Overview","text":"package viewed building block end unto . can consider using anytime ’re tempted write eval(parse(text)) statement.","code":""},{"path":"https://numerious.github.io/evalR/articles/Overview.html","id":"credit","dir":"Articles","previous_headings":"","what":"Credit","title":"Overview","text":"Package logo created using game-icons.net website. Thank great product people willing share talents others.","code":""},{"path":"https://numerious.github.io/evalR/authors.html","id":null,"dir":"","previous_headings":"","what":"Authors","title":"Authors and Citation","text":"Numerious Inc.. Copyright holder, funder. Trevor Olsen. Author, maintainer.","code":""},{"path":"https://numerious.github.io/evalR/authors.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Authors and Citation","text":"Olsen T (2022). evalR: Evaluation Unverified Code. R package version 0.0.2.","code":"@Manual{,   title = {evalR: Evaluation of Unverified Code},   author = {Trevor Olsen},   year = {2022},   note = {R package version 0.0.2}, }"},{"path":[]},{"path":"https://numerious.github.io/evalR/index.html","id":"overview","dir":"","previous_headings":"","what":"Overview","title":"Evaluation of Unverified Code","text":"purpose package generate verification trees evaluations user supplied statements. Trees made parsing statement data structure composed lists. Safe statement evaluations done executing verification trees.","code":""},{"path":"https://numerious.github.io/evalR/index.html","id":"verification-trees","dir":"","previous_headings":"Overview","what":"Verification Trees","title":"Evaluation of Unverified Code","text":"statement can represented tree data structure. quote Wikipedia explain concept: computer science, tree widely used abstract data type represents hierarchical tree structure set connected nodes. node tree can connected many children (depending type tree), must connected exactly one parent, except root node, parent. constraints mean cycles “loops” (node can ancestor), also child can treated like root node subtree, making recursion useful technique tree traversal. contrast linear data structures, many trees represented relationships neighboring nodes single straight line. — Wikipedia.org Tree (data structure) default package know parse R statement tree. theory, supply tokens use package parse language follows similar grammar. verification trees used port R statements languages. example, one use case write formulas excel replicate calculations done R.","code":""},{"path":"https://numerious.github.io/evalR/index.html","id":"safe-evaluation","dir":"","previous_headings":"Overview","what":"Safe Evaluation","title":"Evaluation of Unverified Code","text":"Writing code executes unverified code can powerful dangerous. common approach following pattern: power comes flexibility pattern gives us. usually comes significant performance cost, CPU time cheaper developers. danger comes unknown unknowns. input personal computer may pose much risk. hold input nefarious/clever users server. Execution verification tree generated unverified code different story. risk limited deemed acceptable based supplied tokens. comes greater performance cost, removes danger unverified code.","code":"eval(parse(text=\"unverified_code\"))"},{"path":"https://numerious.github.io/evalR/index.html","id":"functions","dir":"","previous_headings":"","what":"Functions","title":"Evaluation of Unverified Code","text":"focus package limited just creating evaluating trees. next sections cover main functions.","code":""},{"path":"https://numerious.github.io/evalR/index.html","id":"create_tree","dir":"","previous_headings":"Functions","what":"create_tree","title":"Evaluation of Unverified Code","text":"create_tree function takes string generates tree. example, can parse simple expression 2+3: can see structure list lists.","code":"x <- evalR::create_tree(\"2+3\") str(x) #> List of 2 #>  $ pval: list() #>  $ eval:List of 3 #>   ..$ : chr \"+\" #>   ..$ :List of 2 #>   .. ..$ : chr \"atomic\" #>   .. ..$ : chr \"2\" #>   ..$ :List of 2 #>   .. ..$ : chr \"atomic\" #>   .. ..$ : chr \"3\""},{"path":"https://numerious.github.io/evalR/index.html","id":"under-the-hood","dir":"","previous_headings":"Functions > create_tree","what":"Under the hood","title":"Evaluation of Unverified Code","text":"don’t need understand structure tree use . Just like can drive car without knowing engine works. section help reveal trees formed. First lets confirm can replicate tree structure: test passes zero error. full tree made two main branches: pval - stands parenthesis values eval - stands verification values","code":"tree <- list(   pval = list(),   eval = list(\"+\", list(\"atomic\", \"2\"), list(\"atomic\", \"3\")) ) testthat::expect_equal(x,tree)"},{"path":"https://numerious.github.io/evalR/index.html","id":"pval","dir":"","previous_headings":"Functions > create_tree > Under the hood","what":"pval","title":"Evaluation of Unverified Code","text":"first thing function find parenthesis blocks treats sub statements. sub statements becomes element pval element. eval tree references pval entries. example, lets tweak 2+3 (2)+(3): replicate structure: test passes zero error. Now pval list empty. entry (2) (3). entry pval new tree unto contains pval eval branches.","code":"x <- evalR::create_tree(\"(2)+(3)\") str(x) #> List of 2 #>  $ pval:List of 2 #>   ..$ \\0:List of 2 #>   .. ..$ pval: list() #>   .. ..$ eval:List of 2 #>   .. .. ..$ : chr \"atomic\" #>   .. .. ..$ : chr \"2\" #>   ..$ \\1:List of 2 #>   .. ..$ pval: list() #>   .. ..$ eval:List of 2 #>   .. .. ..$ : chr \"atomic\" #>   .. .. ..$ : chr \"3\" #>  $ eval:List of 3 #>   ..$ : chr \"+\" #>   ..$ :List of 2 #>   .. ..$ : chr \"atomic\" #>   .. ..$ : chr \"\\\\0\" #>   ..$ :List of 2 #>   .. ..$ : chr \"atomic\" #>   .. ..$ : chr \"\\\\1\" pval_list <- list(   \"\\\\0\"=list(     pval = list(),     eval = list(\"atomic\", \"2\")   ),   \"\\\\1\"=list(     pval = list(),     eval = list(\"atomic\", \"3\")   ) ) tree <- list(   pval = pval_list,   eval = list(\"+\", list(\"atomic\", \"\\\\0\"), list(\"atomic\", \"\\\\1\")) ) testthat::expect_equal(x,tree)"},{"path":"https://numerious.github.io/evalR/index.html","id":"eval","dir":"","previous_headings":"Functions > create_tree > Under the hood","what":"eval","title":"Evaluation of Unverified Code","text":"eval branch splits statement operators “atomic” elements. example, just parse 2: eval one level deep first element string atomic. signifies end node tree. Lets expand just little bit: Now eval two levels deep. first element states operator - second element another branch looks exactly like eval branch previous example. parenthesis block found, atomic element reference pval element: example, eval second level atomic element \\0. reference \\0 named element pval branch.","code":"x <- evalR::create_tree(\"2\") str(x) #> List of 2 #>  $ pval: list() #>  $ eval:List of 2 #>   ..$ : chr \"atomic\" #>   ..$ : chr \"2\" x <- evalR::create_tree(\"-2\") str(x) #> List of 2 #>  $ pval: list() #>  $ eval:List of 2 #>   ..$ : chr \"-\" #>   ..$ :List of 2 #>   .. ..$ : chr \"atomic\" #>   .. ..$ : chr \"2\" x <- evalR::create_tree(\"-(2)\") str(x) #> List of 2 #>  $ pval:List of 1 #>   ..$ \\0:List of 2 #>   .. ..$ pval: list() #>   .. ..$ eval:List of 2 #>   .. .. ..$ : chr \"atomic\" #>   .. .. ..$ : chr \"2\" #>  $ eval:List of 2 #>   ..$ : chr \"-\" #>   ..$ :List of 2 #>   .. ..$ : chr \"atomic\" #>   .. ..$ : chr \"\\\\0\""},{"path":"https://numerious.github.io/evalR/index.html","id":"eval_tree","dir":"","previous_headings":"Functions","what":"eval_tree","title":"Evaluation of Unverified Code","text":"Given tree, can execute function eval_tree. basic example:","code":"x <- evalR::create_tree(\"2+3\") y <- evalR::eval_tree(x) print(y) #> [1] 5"},{"path":"https://numerious.github.io/evalR/index.html","id":"eval_text","dir":"","previous_headings":"Functions","what":"eval_text","title":"Evaluation of Unverified Code","text":"convenience function contains tree creation stage. eval_text takes text input:","code":"y <- evalR::eval_text(\"2+3\") print(y) #> [1] 5"},{"path":"https://numerious.github.io/evalR/index.html","id":"shared-parameters","dir":"","previous_headings":"","what":"Shared Parameters","title":"Evaluation of Unverified Code","text":"three functions share following parameters: singular_operators - tokens length 1 operate right hand value. example, - token operator negate vector. NULL value replaced c(\"-\", \"!\"). binary_operators - tokens length operate left right hand values. example, + token operator adds left vector right vector. NULL value replaced c(\",\",\"|\", \"&\", \"<=\", \"<\", \">=\", \">\", \"==\", \"!=\", \"+\", \"-\", \"*\", \"%/%\", \"/\", \"%%\", \"%%\", \":\", \"^\"). order determines precedence operators. valid_functions - tokens length prefixed parenthesis block specify function run provided parameters within block. example, log token evaluate logarithm value first parameter. Note named parameters support. NULL value replaced c(\"log\",\"c\", \"\",\"\", \"abs\",\"ifelse\"). example, want able use function rnorm, need provide item valid_functions parameter:","code":"set.seed(102) y <- evalR::eval_text(\"2+rnorm(1)\", valid_functions=\"rnorm\") print(y) #> [1] 2.180523"},{"path":"https://numerious.github.io/evalR/index.html","id":"map-parameter","dir":"","previous_headings":"","what":"map Parameter","title":"Evaluation of Unverified Code","text":"eval_tree eval_text share following parameter: map - named list data.frames/lists/matrices. names keys referencing values parameters. parameter limits scope execution environment (strictly technical sense). words, limit values can reference. basic concert example: complex example:","code":"map_obj <- list(\"#\" = data.frame(x = 1:5, y = 5:1)) y <- evalR::eval_text(\"log(#x#)\", map=map_obj) print(y) #> [1] 0.0000000 0.6931472 1.0986123 1.3862944 1.6094379 map_obj <- list(\"#\" = data.frame(x = 1:5, y = 5:1),\"$\" = list(z = -(1:5))) y <- evalR::eval_text(\"#x# + $z$\", map=map_obj) print(y) #> [1] 0 0 0 0 0"},{"path":"https://numerious.github.io/evalR/index.html","id":"microbenchmark","dir":"","previous_headings":"","what":"microbenchmark","title":"Evaluation of Unverified Code","text":"get sense performance. Lets compare different ways can run log(1+2): pure R evaluation much faster methods. surprise. evalR::eval_tree block takes couple times longer eval(parse(text)) execution. trade considering reduced risk. eval(parse(text)) execution sometimes much slower ran outside R markdown. also see evalR::eval_text takes much longer evalR::eval_tree. majority evalR::eval_text time comes internal call evalR::create_tree. free lunch principle comes play. cost reduced risk spent creating tree. ’re lucky enough set user input evaluated multiple times, design pattern generating tree using evalR::eval_tree give similar performance straight eval call.","code":"text <- \"log(1+3)\" tree <- evalR::create_tree(text) microbenchmark::microbenchmark(   {log(1+2)},   {eval(parse(text=text))},   {evalR::eval_tree(tree)},   {evalR::eval_text(text)},   {evalR::create_tree(text)}, n=1000) #> Warning in microbenchmark::microbenchmark({: Could not measure a positive #> execution time for 60 evaluations. #> Unit: nanoseconds #>                              expr    min     lq   mean median     uq    max #>                {     log(1 + 2) }    100    100    439    200    300  13500 #>  {     eval(parse(text = text)) }   4400   6100   8517   6800   8850  28400 #>    {     evalR::eval_tree(tree) }  19100  21050  26502  22300  25500  92500 #>    {     evalR::eval_text(text) } 158200 166900 194175 177250 218800 296400 #>  {     evalR::create_tree(text) } 138100 147600 170996 157150 185100 290000 #>                                 n      0      0      0      0      0      0 #>  neval #>    100 #>    100 #>    100 #>    100 #>    100 #>    100"},{"path":"https://numerious.github.io/evalR/index.html","id":"final-thoughts","dir":"","previous_headings":"","what":"Final Thoughts","title":"Evaluation of Unverified Code","text":"package viewed building block end unto . can consider using anytime ’re tempted write eval(parse(text)) statement.","code":""},{"path":"https://numerious.github.io/evalR/index.html","id":"credit","dir":"","previous_headings":"","what":"Credit","title":"Evaluation of Unverified Code","text":"Package logo created using game-icons.net website. Thank great product people willing share talents others.","code":""},{"path":"https://numerious.github.io/evalR/LICENSE.html","id":null,"dir":"","previous_headings":"","what":"MIT License","title":"MIT License","text":"Copyright (c) 2022 Numerious Inc. Permission hereby granted, free charge, person obtaining copy software associated documentation files (“Software”), deal Software without restriction, including without limitation rights use, copy, modify, merge, publish, distribute, sublicense, /sell copies Software, permit persons Software furnished , subject following conditions: copyright notice permission notice shall included copies substantial portions Software. SOFTWARE PROVIDED “”, WITHOUT WARRANTY KIND, EXPRESS IMPLIED, INCLUDING LIMITED WARRANTIES MERCHANTABILITY, FITNESS PARTICULAR PURPOSE NONINFRINGEMENT. EVENT SHALL AUTHORS COPYRIGHT HOLDERS LIABLE CLAIM, DAMAGES LIABILITY, WHETHER ACTION CONTRACT, TORT OTHERWISE, ARISING , CONNECTION SOFTWARE USE DEALINGS SOFTWARE.","code":""},{"path":"https://numerious.github.io/evalR/reference/binary_operators_ref.html","id":null,"dir":"Reference","previous_headings":"","what":"arguments to use with @inheritParams — binary_operators_ref","title":"arguments to use with @inheritParams — binary_operators_ref","text":"arguments use @inheritParams","code":""},{"path":"https://numerious.github.io/evalR/reference/binary_operators_ref.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"arguments to use with @inheritParams — binary_operators_ref","text":"binary_operators Tokens length operate left right hand values. example, `+` token operator adds left vector right vector. NULL value replaced c(\",\", \"|\", \"&\", \"<=\", \"<\", \">=\", \">\", \"==\", \"!=\", \"+\", \"-\", \"*\", \"%/%\", \"/\", \"%%\", \"%%\", \":\", \"^\"). order determines precedence operators.","code":""},{"path":"https://numerious.github.io/evalR/reference/create_tree.html","id":null,"dir":"Reference","previous_headings":"","what":"Convert a statement into an evaluation tree — create_tree","title":"Convert a statement into an evaluation tree — create_tree","text":"Function break text list lists.","code":""},{"path":"https://numerious.github.io/evalR/reference/create_tree.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Convert a statement into an evaluation tree — create_tree","text":"","code":"create_tree(   text,   singular_operators = NULL,   binary_operators = NULL,   valid_functions = NULL )"},{"path":"https://numerious.github.io/evalR/reference/create_tree.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Convert a statement into an evaluation tree — create_tree","text":"text string/code/statement want parse. singular_operators Tokens length 1 operate right hand value. example, `-` token operator negate vector. NULL value replaced c(\"-\", \"!\"). binary_operators Tokens length operate left right hand values. example, `+` token operator adds left vector right vector. NULL value replaced c(\",\", \"|\", \"&\", \"<=\", \"<\", \">=\", \">\", \"==\", \"!=\", \"+\", \"-\", \"*\", \"%/%\", \"/\", \"%%\", \"%%\", \":\", \"^\"). order determines precedence operators. valid_functions Tokens length prefixed parenthesis block specify function run provided parameters within block. example, `log` token evaluate logarithm value first parameter. Note named parameters support. NULL value replaced c(\"log\", \"c\", \"\", \"\", \"abs\", \"ifelse\").","code":""},{"path":"https://numerious.github.io/evalR/reference/create_tree.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Convert a statement into an evaluation tree — create_tree","text":"list lists. words, tree data structure made lists.","code":""},{"path":"https://numerious.github.io/evalR/reference/create_tree.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Convert a statement into an evaluation tree — create_tree","text":"See vignette(\"Overview\", package = \"evalR\")","code":""},{"path":"https://numerious.github.io/evalR/reference/create_tree.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Convert a statement into an evaluation tree — create_tree","text":"","code":"x <- create_tree(\"2 * (3 + 5)\") str(x) #> List of 2 #>  $ pval:List of 1 #>   ..$ \\0:List of 2 #>   .. ..$ pval: list() #>   .. ..$ eval:List of 3 #>   .. .. ..$ : chr \"+\" #>   .. .. ..$ :List of 2 #>   .. .. .. ..$ : chr \"atomic\" #>   .. .. .. ..$ : chr \"3\" #>   .. .. ..$ :List of 2 #>   .. .. .. ..$ : chr \"atomic\" #>   .. .. .. ..$ : chr \"5\" #>  $ eval:List of 3 #>   ..$ : chr \"*\" #>   ..$ :List of 2 #>   .. ..$ : chr \"atomic\" #>   .. ..$ : chr \"2\" #>   ..$ :List of 2 #>   .. ..$ : chr \"atomic\" #>   .. ..$ : chr \"\\\\0\""},{"path":"https://numerious.github.io/evalR/reference/eval_text.html","id":null,"dir":"Reference","previous_headings":"","what":"Safely evaluate text — eval_text","title":"Safely evaluate text — eval_text","text":"Safe alternative using eval + parse","code":""},{"path":"https://numerious.github.io/evalR/reference/eval_text.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Safely evaluate text — eval_text","text":"","code":"eval_text(   text,   singular_operators = NULL,   binary_operators = NULL,   valid_functions = NULL,   map = NULL,   mapping_names = NULL )"},{"path":"https://numerious.github.io/evalR/reference/eval_text.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Safely evaluate text — eval_text","text":"text string/code/statement want parse. singular_operators Tokens length 1 operate right hand value. example, `-` token operator negate vector. NULL value replaced c(\"-\", \"!\"). binary_operators Tokens length operate left right hand values. example, `+` token operator adds left vector right vector. NULL value replaced c(\",\", \"|\", \"&\", \"<=\", \"<\", \">=\", \">\", \"==\", \"!=\", \"+\", \"-\", \"*\", \"%/%\", \"/\", \"%%\", \"%%\", \":\", \"^\"). order determines precedence operators. valid_functions Tokens length prefixed parenthesis block specify function run provided parameters within block. example, `log` token evaluate logarithm value first parameter. Note named parameters support. NULL value replaced c(\"log\", \"c\", \"\", \"\", \"abs\", \"ifelse\"). map named list data.frames/lists/matrices. names keys referencing values text parameters. mapping_names Optional argument make function faster limit map elements can referenced.","code":""},{"path":"https://numerious.github.io/evalR/reference/eval_text.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Safely evaluate text — eval_text","text":"numeric logical vector","code":""},{"path":"https://numerious.github.io/evalR/reference/eval_text.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Safely evaluate text — eval_text","text":"See vignette(\"Overview\", package = \"evalR\")","code":""},{"path":"https://numerious.github.io/evalR/reference/eval_text.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Safely evaluate text — eval_text","text":"","code":"eval_text(\"1 + 2\") #> [1] 3  # using the map parameter  map_obj <- list(\"#\" = data.frame(x = 1:5, y = 5:1),\"$\" = list(z = -(1:5))) y <- evalR::eval_text(\"#x# + $z$\", map=map_obj)"},{"path":"https://numerious.github.io/evalR/reference/eval_tree.html","id":null,"dir":"Reference","previous_headings":"","what":"Safely evaluate tree — eval_tree","title":"Safely evaluate tree — eval_tree","text":"Safe alternative using eval + parse string already converted tree.","code":""},{"path":"https://numerious.github.io/evalR/reference/eval_tree.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Safely evaluate tree — eval_tree","text":"","code":"eval_tree(   tree,   singular_operators = NULL,   binary_operators = NULL,   valid_functions = NULL,   map = NULL,   mapping_names = NULL )"},{"path":"https://numerious.github.io/evalR/reference/eval_tree.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Safely evaluate tree — eval_tree","text":"tree output object create_tree singular_operators Tokens length 1 operate right hand value. example, `-` token operator negate vector. NULL value replaced c(\"-\", \"!\"). binary_operators Tokens length operate left right hand values. example, `+` token operator adds left vector right vector. NULL value replaced c(\",\", \"|\", \"&\", \"<=\", \"<\", \">=\", \">\", \"==\", \"!=\", \"+\", \"-\", \"*\", \"%/%\", \"/\", \"%%\", \"%%\", \":\", \"^\"). order determines precedence operators. valid_functions Tokens length prefixed parenthesis block specify function run provided parameters within block. example, `log` token evaluate logarithm value first parameter. Note named parameters support. NULL value replaced c(\"log\", \"c\", \"\", \"\", \"abs\", \"ifelse\"). map named list data.frames/lists/matrices. names keys referencing values text parameters. mapping_names Optional argument make function faster limit map elements can referenced.","code":""},{"path":"https://numerious.github.io/evalR/reference/eval_tree.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Safely evaluate tree — eval_tree","text":"numeric logical vector","code":""},{"path":"https://numerious.github.io/evalR/reference/eval_tree.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Safely evaluate tree — eval_tree","text":"See vignette(\"Overview\", package = \"evalR\")","code":""},{"path":"https://numerious.github.io/evalR/reference/eval_tree.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Safely evaluate tree — eval_tree","text":"","code":"tree <- create_tree(\"1 + 2\") eval_tree(tree) #> [1] 3"},{"path":"https://numerious.github.io/evalR/reference/find_parenthesis.html","id":null,"dir":"Reference","previous_headings":"","what":"Helper to find first block of parenthesis — find_parenthesis","title":"Helper to find first block of parenthesis — find_parenthesis","text":"function search first block parenthesis return found. Otherwise, return \"\".","code":""},{"path":"https://numerious.github.io/evalR/reference/find_parenthesis.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Helper to find first block of parenthesis — find_parenthesis","text":"","code":"find_parenthesis(text)"},{"path":"https://numerious.github.io/evalR/reference/find_parenthesis.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Helper to find first block of parenthesis — find_parenthesis","text":"text string/code/statement want parse.","code":""},{"path":"https://numerious.github.io/evalR/reference/find_parenthesis.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Helper to find first block of parenthesis — find_parenthesis","text":"substring. Either \"\" first parenthesis block.","code":""},{"path":"https://numerious.github.io/evalR/reference/find_parenthesis.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Helper to find first block of parenthesis — find_parenthesis","text":"","code":"# returns \"\" find_parenthesis(\"3 + 5\") #> [1] \"\" # returns \"(3 + 5)\" find_parenthesis(\"2 * (3 + 5)\") #> [1] \"(3 + 5)\""},{"path":"https://numerious.github.io/evalR/reference/mapping_names_ref.html","id":null,"dir":"Reference","previous_headings":"","what":"arguments to use with @inheritParams — mapping_names_ref","title":"arguments to use with @inheritParams — mapping_names_ref","text":"arguments use @inheritParams","code":""},{"path":"https://numerious.github.io/evalR/reference/mapping_names_ref.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"arguments to use with @inheritParams — mapping_names_ref","text":"mapping_names Optional argument make function faster limit map elements can referenced.","code":""},{"path":"https://numerious.github.io/evalR/reference/map_ref.html","id":null,"dir":"Reference","previous_headings":"","what":"arguments to use with @inheritParams — map_ref","title":"arguments to use with @inheritParams — map_ref","text":"arguments use @inheritParams","code":""},{"path":"https://numerious.github.io/evalR/reference/map_ref.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"arguments to use with @inheritParams — map_ref","text":"map named list data.frames/lists/matrices. names keys referencing values text parameters.","code":""},{"path":"https://numerious.github.io/evalR/reference/pval_ref.html","id":null,"dir":"Reference","previous_headings":"","what":"arguments to use with @inheritParams — pval_ref","title":"arguments to use with @inheritParams — pval_ref","text":"arguments use @inheritParams","code":""},{"path":"https://numerious.github.io/evalR/reference/pval_ref.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"arguments to use with @inheritParams — pval_ref","text":"pval pval branch tree","code":""},{"path":"https://numerious.github.io/evalR/reference/singular_operators_ref.html","id":null,"dir":"Reference","previous_headings":"","what":"arguments to use with @inheritParams — singular_operators_ref","title":"arguments to use with @inheritParams — singular_operators_ref","text":"arguments use @inheritParams","code":""},{"path":"https://numerious.github.io/evalR/reference/singular_operators_ref.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"arguments to use with @inheritParams — singular_operators_ref","text":"singular_operators Tokens length 1 operate right hand value. example, `-` token operator negate vector. NULL value replaced c(\"-\", \"!\").","code":""},{"path":"https://numerious.github.io/evalR/reference/text_ref.html","id":null,"dir":"Reference","previous_headings":"","what":"arguments to use with @inheritParams — text_ref","title":"arguments to use with @inheritParams — text_ref","text":"arguments use @inheritParams","code":""},{"path":"https://numerious.github.io/evalR/reference/text_ref.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"arguments to use with @inheritParams — text_ref","text":"text string/code/statement want parse.","code":""},{"path":"https://numerious.github.io/evalR/reference/tree_ref.html","id":null,"dir":"Reference","previous_headings":"","what":"arguments to use with @inheritParams — tree_ref","title":"arguments to use with @inheritParams — tree_ref","text":"arguments use @inheritParams","code":""},{"path":"https://numerious.github.io/evalR/reference/tree_ref.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"arguments to use with @inheritParams — tree_ref","text":"tree output object create_tree","code":""},{"path":"https://numerious.github.io/evalR/reference/valid_functions_ref.html","id":null,"dir":"Reference","previous_headings":"","what":"arguments to use with @inheritParams — valid_functions_ref","title":"arguments to use with @inheritParams — valid_functions_ref","text":"arguments use @inheritParams","code":""},{"path":"https://numerious.github.io/evalR/reference/valid_functions_ref.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"arguments to use with @inheritParams — valid_functions_ref","text":"valid_functions Tokens length prefixed parenthesis block specify function run provided parameters within block. example, `log` token evaluate logarithm value first parameter. Note named parameters support. NULL value replaced c(\"log\", \"c\", \"\", \"\", \"abs\", \"ifelse\").","code":""},{"path":"https://numerious.github.io/evalR/news/index.html","id":"evalr-002-2022-08-25","dir":"Changelog","previous_headings":"","what":"evalR 0.0.2 (2022-08-25)","title":"evalR 0.0.2 (2022-08-25)","text":"Minor documentation changes","code":""},{"path":"https://numerious.github.io/evalR/news/index.html","id":"evalr-001-2022-08-24","dir":"Changelog","previous_headings":"","what":"evalR 0.0.1 (2022-08-24)","title":"evalR 0.0.1 (2022-08-24)","text":"CRAN release: 2022-08-25 initial release","code":""}]
